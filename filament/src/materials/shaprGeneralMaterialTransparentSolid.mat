material {
    name : generalShaprTransparentSolid,
    requires : [tangents],
    shadingModel : lit,
    blending : fade,
    transparency : twoPassesTwoSides,
    refractionMode : screenspace,
    refractionType : solid,
    parameters : [
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // Attributes that may have a texture assigned to them. A single control to set their value when
        // no texture is selected is optional but always named as the material, if present.
        //////////////////////////////////////////////////////////////////////////////////////////////////
        {
            type : int,
            name : useAlbedoTexture
        },
        {
            type : sampler2d,
            name : albedoTexture
        },
        {
            type : float4,
            name : albedo
        },

        {
            type : int,
            name : useNormalTexture
        },
        {
            type : sampler2d,
            name : normalTexture
        },

        {
            type : int,
            name : useRoughnessTexture
        },        
        {
            type : sampler2d,
            name : roughnessTexture
        },
        {
            type : float,
            name : roughness
        },

        {
            type : int,
            name : useClearCoatNormalTexture
        },
        {
            type : sampler2d,
            name : clearCoatNormalTexture
        },

        {
            type : int,
            name : useClearCoatRoughnessTexture
        },        
        {
            type : sampler2d,
            name : clearCoatRoughnessTexture
        },
        {
            type : float,
            name : clearCoatRoughness
        },

        {
            type : int,
            name : useBumpTexture
        },
        {
            type : sampler2d,
            name : bumpTexture
        },

        {
            type : int,
            name : useMetallicTexture
        },
        {
            type : sampler2d,
            name : metallicTexture
        },
        {
            type : float,
            name : metallic
        },

        {
            type : int,
            name : useTransmissionTexture
        },
        {
            type : sampler2d,
            name : transmissionTexture
        },
        {
            type : float,
            name : transmission
        },

        {
            type : int,
            name : useIorTexture
        },
        {
            type : sampler2d,
            name : iorTexture
        },
        {   // default: 1.5
            type : float,
            name : ior
        },


        // this is somewhat special because the value here will be assigned to both material.thickness and material.microThickness
        {
            type : int,
            name : useThicknessTexture
        },
        {
            type : sampler2d,
            name : thicknessTexture
        },
        {
            type : float,
            name : thickness
        },

        //////////////////////////////////////////////////////////////////////////////////////////////////
        // Texture lookup scaling that transforms world coordinates to triplanar coordinates
        //////////////////////////////////////////////////////////////////////////////////////////////////

        { // .r: baseColor, .g: normal|roughness|metallic, .b: clearCoat{Normal|Roughness|value} scaler, .a: ior, transmission, thickness|microThickness texture scalers
            type : float4,
            name : textureScaler
        },
        {
            type : float,
            name : bumpScale
        },
        { // this is a compatibility attribute with the GltfViewer extra tweaks
            type : float4,
            name : scalingControl
        },
        { // this is a compatibility attribute with the Filament generated materials
            type : float,
            name : normalScale
        },
        { // this is a compatibility attribute with the Filament generated materials
            type : float,
            name : clearCoatNormalScale
        },

        //////////////////////////////////////////////////////////////////////////////////////////////////
        // material attributes that are purely driven by UBO values
        //////////////////////////////////////////////////////////////////////////////////////////////////

        {
            type : float,
            name : clearCoat
        },
        {
            type : float,
            name : specularIntensity
        },
        {
            type : float,
            name : iorScale
        },        
        {
            type : float,
            name : maxThickness
        },        
        {
            type : float3,
            name : absorption
        }
    ]
}

fragment {
    const float EPSILON = 1.0 / 2048.0;

    // A simple linear blend with normalization
    vec3 computeWeights( vec3 normal ) {
#if 0
        // This was the blend Zaza used:
        // We assume that the normal is of unit length, so below is an actual barycentric combination
        return normal * normal;
#else
        // This one has a region where there is no blend, creating more defined interpolations
        vec3 blend = abs(normal.xyz);
        blend = max(blend - 0.2, vec3(0.0) );
        blend /= (blend.x + blend.y + blend.z);
        return blend;
#endif
    }

    vec4 triplanarTexture(sampler2D tex, float scaler, highp vec3 pos, lowp vec3 normal) {
        // Depending on the resolution of the texture, we may want to multiply the texture coordinates
        vec3 queryPos = scaler * pos;
        vec3 weights = computeWeights(normal);
        return weights.x * texture(tex, queryPos.yz) +
               weights.y * texture(tex, queryPos.xz) +
               weights.z * texture(tex, queryPos.xy);
    }


    vec3 unpackNormal( vec2 packedNormal ) {
        float x = packedNormal.x * 2.0 - 1.0;
        float y = packedNormal.y * 2.0 - 1.0;
        return vec3( x, y, sqrt( clamp( 1.0 - x*x - y*y, 0.0, 1.0 ) ) );
    }
    vec3 unpackNormal( vec3 packedNormal ) {
        return packedNormal * 2.0 - 1.0;
    }
    // This is a whiteout blended tripalanar normal mapping, where each plane's tangent frame is
    // approximated by the appropriate sequence and flips of world space axes. For more details
    // Refer to https://bgolus.medium.com/normal-mapping-for-a-triplanar-shader-10bf39dca05a
    vec3 triplanarNormalMap( sampler2D normalMap, float scaler, highp vec3 pos, lowp vec3 normal ) {
        // Whiteout blend
        // Triplanar uvs
        vec2 uvX = scaler * pos.zy; // x facing plane
        vec2 uvY = scaler * pos.xz; // y facing plane
        vec2 uvZ = scaler * pos.xy; // z facing plane
        // Tangent space normal maps
#if 0
        // 3-channel TS normal texture
        lowp vec3 tnormalX = unpackNormal( texture( normalMap, uvX ).xyz );
        lowp vec3 tnormalY = unpackNormal( texture( normalMap, uvY ).xyz );
        lowp vec3 tnormalZ = unpackNormal( texture( normalMap, uvZ ).xyz );
#else
        // 2-channel XY TS normal texture: this saves 33% on storage, but also
        // pushes us into the direction of choosing what attributes to pack
        // together into the same texture (e.g. normal-roughness-metallic?)
        lowp vec3 tnormalX = unpackNormal( texture( normalMap, uvX ).xy );
        lowp vec3 tnormalY = unpackNormal( texture( normalMap, uvY ).xy );
        lowp vec3 tnormalZ = unpackNormal( texture( normalMap, uvZ ).xy );
#endif
        // Swizzle world normals into tangent space and apply Whiteout blend
        tnormalX = vec3(
            tnormalX.xy + normal.zy,
            abs(tnormalX.z) * normal.x
            );
        tnormalY = vec3(
            tnormalY.xy + normal.xz,
            abs(tnormalY.z) * normal.y
            );
        tnormalZ = vec3(
            tnormalZ.xy + normal.xy,
            abs(tnormalZ.z) * normal.z
            );
        // Compute blend weights
        vec3 blend = computeWeights( normal );
        // Swizzle tangent normals to match world orientation and triblend
        return normalize( tnormalX.zyx * blend.x +
                          tnormalY.xzy * blend.y +
                          tnormalZ.xyz * blend.z );
    }

    void material(inout MaterialInputs material) {
        material.specularScale  = 1.0 + materialParams.scalingControl.x;
        material.roughnessScale = 1.0 + materialParams.scalingControl.y;
        material.diffuseScale   = 1.0 + materialParams.scalingControl.z;
        material.clearCoatScale = 1.0 + materialParams.scalingControl.w;

        highp vec3 pos = getWorldPosition() + getWorldOffset();
#if 1
        highp vec3 normal = getWorldGeometricNormalVector();
#else
        // Since I have to re-add this so many times to debug issues, I'm leaving this commented out for the time being
        // Still, be careful: OGL did not expose the fine gradients until 4.5 (!!!) core, so you cannot know if these are
        // coarse (=constant for the 2x2 fragment quad) or fine (forward/backward difference'd) derivatives
        vec3 DxPos = dFdx( pos );
        vec3 DyPos = dFdy( pos );
        vec3 normal = normalize( cross( DxPos, DyPos ) );
#endif

        if ( materialParams.useNormalTexture == 1 ) {
            // We combine the normals in world space, hence the transformation in the end from world to tangent, assuming an
            // orthonormal tangent frame (which may not hold actually but looks fine enough for now).
            vec3 normalWS = triplanarNormalMap( materialParams_normalTexture, materialParams.textureScaler.y, pos, normal );
            material.normal = normalWS * getWorldTangentFrame();
        } 

        mat3 tangentFrame = getWorldTangentFrame();
        if ( materialParams.useBumpTexture == 1 ) {
            float bump = materialParams.bumpScale * triplanarTexture(materialParams_bumpTexture, materialParams.textureScaler.y, pos, normal).r;
            highp float dBumpDu = (materialParams.bumpScale * triplanarTexture(materialParams_bumpTexture, materialParams.textureScaler.y, pos + EPSILON * tangentFrame[0], normal).r - bump);
            highp float dBumpDv = (materialParams.bumpScale * triplanarTexture(materialParams_bumpTexture, materialParams.textureScaler.y, pos + EPSILON * tangentFrame[1], normal).r - bump);

            highp vec3 du = tangentFrame[0] + dBumpDu * normal;
            highp vec3 dv = tangentFrame[1] + dBumpDv * normal;

            if ( materialParams.useNormalTexture == 1 ) {
                material.normal = normalize( material.normal + normalize(cross(du, dv) * tangentFrame) );
            } else {
                vec3 bumpNormal = normalize(cross(du, dv) * tangentFrame);
                material.normal = normalize( vec3( material.normal.xy * bumpNormal.z + bumpNormal.xy * material.normal.z , 1.0) );
            }
        }
        // By this time the normal should be ready, it is safe to apply the normal scale
        material.normal.xy *= materialParams.normalScale;

        // Let Filament compute the global shading parameters. Note that material.normal stays in tangent space. Its world space coordinates
        // are stored in the global variable shading_normal.
        prepareMaterial(material);

        // And overwrite whatever we need to overwrite
        if ( materialParams.useAlbedoTexture == 1 ) {
            material.baseColor = triplanarTexture(materialParams_albedoTexture, materialParams.textureScaler.x, pos, normal);
        } else {
            material.baseColor = materialParams.albedo;
        }
        // Pre-multiply by alpha
        material.baseColor.rgb *= material.baseColor.a;

        // Careful: reflectance affects non-metals, so this can make things overly shiny
        material.reflectance = materialParams.reflectance * clamp( 1.0 - material.roughness, 0.0, 1.0 );

        // TODO @gvalasek: to conform to standards, .r is treated as occlusion, .b is roughness,
        //       and .b as metallness. For now, only roughness is taken into account for M2.
        if ( materialParams.useRoughnessTexture == 1 ) {
            material.roughness = triplanarTexture(materialParams_roughnessTexture, materialParams.textureScaler.y, pos, normal).r;
        } else {
            material.roughness = materialParams.roughness;
        }

        // TODO @gvalasek: see as above, technically all this should have been a single fetch
        if ( materialParams.useMetallicTexture == 1 ) {
            material.metallic = triplanarTexture(materialParams_metallicTexture, materialParams.textureScaler.y, pos, normal).r;
        } else {
            material.metallic = materialParams.metallic;
        }

        if ( materialParams.useClearCoatRoughnessTexture == 1 ) {
            material.clearCoatRoughness = triplanarTexture(materialParams_clearCoatRoughnessTexture, materialParams.textureScaler.z, pos, normal).r;
        } else {
            material.clearCoatRoughness = materialParams.clearCoatRoughness;
        }

        if ( materialParams.useClearCoatNormalTexture == 1 ) {
            material.clearCoatNormal = triplanarNormalMap( materialParams_clearCoatNormalTexture, materialParams.textureScaler.z, pos, normal );
        }

        // Careful: reflectance affects non-metals, so this can make things overly shiny
        material.reflectance = 1.0 - material.roughness;

        material.anisotropy = 0.0;
        material.clearCoat = materialParams.clearCoat;

        //////////////////////////////////////////////////////////////////////////////////////////////////
        // Attributes for transparent/refractive materials
        //////////////////////////////////////////////////////////////////////////////////////////////////
        material.absorption = materialParams.absorption;

        if ( materialParams.useIorTexture == 1 ) {
            material.ior = 1.0 + materialParams.iorScale * triplanarTexture(materialParams_iorTexture, materialParams.textureScaler.w, pos, normal).r;
        } else {
            material.ior = 1.0 + materialParams.iorScale * ( materialParams.ior - 1.0 );
        }


        if ( materialParams.useTransmissionTexture == 1 ) {
            material.transmission = triplanarTexture(materialParams_transmissionTexture, materialParams.textureScaler.w, pos, normal).r;
        } else {
            material.transmission = materialParams.transmission;
        }

        float thicknessValue = 0.0;
        if ( materialParams.useThicknessTexture == 1 ) {
            thicknessValue = triplanarTexture(materialParams_thicknessTexture, materialParams.textureScaler.w, pos, normal).r;
        } else {
            thicknessValue = materialParams.thickness;
        }
        thicknessValue *= materialParams.maxThickness;

#if defined(SHADING_MODEL_SUBSURFACE) || defined(HAS_REFRACTION)
            material.thickness = thicknessValue; // default 0.5
#endif
#if defined(MATERIAL_HAS_MICRO_THICKNESS) && (REFRACTION_TYPE == REFRACTION_TYPE_THIN)
            material.microThickness = thicknessValue; // default 0.0
#endif

        //--------
        // simplies
        //--------
        material.specularIntensity = materialParams.specularIntensity;
    }
}
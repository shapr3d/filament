material {
    name : dofMedian,
    parameters : [
        {
            type : sampler2d,
            name : dof,
            precision: medium
        },
        {
            type : sampler2d,
            name : alpha,
            precision: medium
        },
        {
            type : sampler2d,
            name : tiles,
            precision: medium
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        postProcess.vertex.xy = uvToRenderTargetUV(postProcess.normalizedUV);
    }
}

fragment {

#include "dofUtils.fs"

layout(location = 1) out float outAlpha;

/*
 * Based on "A Fast, Small-Radius GPU Median Filter"
 * by Morgan McGuire & Williams College
 * [https://casual-effects.com/research/McGuire2008Median/index.html]
 */

#define MINLEFTMAXRIGHT_TEMPLATE(type)                                                                      \
void sort2(inout type a, inout type b) {                                                                    \
    type t = a;                                                                                             \
    a = min(a, b);                                                                                          \
    b = max(t, b);                                                                                          \
}                                                                                                           \
                                                                                                            \
void minLeft(inout type a, inout type b, inout type c) {                                                    \
    sort2(a, b);                                                                                            \
    sort2(a, c);                                                                                            \
}                                                                                                           \
                                                                                                            \
void maxRight(inout type a, inout type b, inout type c) {                                                   \
    sort2(b, c);                                                                                            \
    sort2(a, c);                                                                                            \
}                                                                                                           \
                                                                                                            \
void minLeftMaxRight(inout type a, inout type b, inout type c) {                                            \
    maxRight(a, b, c);                                                                                      \
    sort2(a, b);                                                                                            \
}                                                                                                           \
                                                                                                            \
void minLeftMaxRight(inout type a, inout type b, inout type c, inout type d) {                              \
    sort2(a, b);                                                                                            \
    sort2(c, d);                                                                                            \
    sort2(a, c);                                                                                            \
    sort2(b, d);                                                                                            \
}                                                                                                           \
                                                                                                            \
void minLeftMaxRight(inout type a, inout type b, inout type c, inout type d, inout type e) {                \
    sort2(a, b);                                                                                            \
    sort2(c, d);                                                                                            \
    minLeft(a, c, e);                                                                                       \
    maxRight(b, d, e);                                                                                      \
}                                                                                                           \
                                                                                                            \
void minLeftMaxRight(inout type a, inout type b, inout type c, inout type d, inout type e, inout type f) {  \
    sort2(a, d);                                                                                            \
    sort2(b, e);                                                                                            \
    sort2(c, f);                                                                                            \
    minLeft(a, b, c);                                                                                       \
    maxRight(d, e, f);                                                                                      \
}

MINLEFTMAXRIGHT_TEMPLATE(vec4)
MINLEFTMAXRIGHT_TEMPLATE(float)



// - we can't use a function because offset must be a constant expression
// - we can't use line continuation because that's not supported on desktop
#define makeSampleColor(ij, o) texelFetchOffset(materialParams_dof, ij, 0, o)
#define makeSampleAlpha(ij, o) texelFetchOffset(materialParams_alpha, ij, 0, o).r

vec4 medianColor(ivec2 ij) {
    vec4 v[9];
    v[0] = makeSampleColor(ij, ivec2(-1, -1));
    v[1] = makeSampleColor(ij, ivec2( 0, -1));
    v[2] = makeSampleColor(ij, ivec2( 1, -1));
    v[3] = makeSampleColor(ij, ivec2(-1,  0));
    v[4] = makeSampleColor(ij, ivec2( 0,  0));
    v[5] = makeSampleColor(ij, ivec2( 1,  0));
    v[6] = makeSampleColor(ij, ivec2(-1,  1));
    v[7] = makeSampleColor(ij, ivec2( 0,  1));
    v[8] = makeSampleColor(ij, ivec2( 1,  1));

    // max() is a faster alternative to the median filter, but it looks pretty bad imho
    //return max(v[0], max(v[1], max(v[2], max(v[3], max(v[4], max(v[5], max(v[6], max(v[7], v[8]))))))));
    // it looks better (than max()) to skip this filter and keep the noise
    //return v[4];

    minLeftMaxRight(v[0], v[1], v[2], v[3], v[4], v[5]);
    minLeftMaxRight(v[1], v[2], v[3], v[4], v[6]);
    minLeftMaxRight(v[2], v[3], v[4], v[7]);
    minLeftMaxRight(v[3], v[4], v[8]);
    return v[4];
}


float medianAlpha(ivec2 ij) {
    float v[9];
    v[0] = makeSampleAlpha(ij, ivec2(-1, -1));
    v[1] = makeSampleAlpha(ij, ivec2( 0, -1));
    v[2] = makeSampleAlpha(ij, ivec2( 1, -1));
    v[3] = makeSampleAlpha(ij, ivec2(-1,  0));
    v[4] = makeSampleAlpha(ij, ivec2( 0,  0));
    v[5] = makeSampleAlpha(ij, ivec2( 1,  0));
    v[6] = makeSampleAlpha(ij, ivec2(-1,  1));
    v[7] = makeSampleAlpha(ij, ivec2( 0,  1));
    v[8] = makeSampleAlpha(ij, ivec2( 1,  1));

    // max() is a faster alternative to the median filter, but it looks pretty bad imho
    //return max(v[0], max(v[1], max(v[2], max(v[3], max(v[4], max(v[5], max(v[6], max(v[7], v[8]))))))));
    // it looks better (than max()) to skip this filter and keep the noise
    //return v[4];

    minLeftMaxRight(v[0], v[1], v[2], v[3], v[4], v[5]);
    minLeftMaxRight(v[1], v[2], v[3], v[4], v[6]);
    minLeftMaxRight(v[2], v[3], v[4], v[7]);
    minLeftMaxRight(v[3], v[4], v[8]);
    return v[4];
}

void postProcess(inout PostProcessInputs postProcess) {
    vec2 tiles = textureLod(materialParams_tiles, variable_vertex.xy, 0.0).rg;
    vec4 dof = vec4(0.0);
    float alpha = 0.0;

    if (!isTrivialTile(tiles)) {
        vec2 size = vec2(textureSize(materialParams_dof, 0));
        ivec2 ij = ivec2(variable_vertex.xy * size);
        dof = medianColor(ij);
        alpha = medianAlpha(ij);
    }

    postProcess.color  = dof;
    outAlpha           = alpha;
}

}

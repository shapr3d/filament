material {
    name : general,
    requires : [tangents],
    shadingModel : lit,
    parameters : [
        {
            type : sampler2d,
            name : roughnessTexture
        },
        {
            type : float,
            name : roughness
        },
        {
            type : sampler2d,
            name : bumpTexture
        },
        {
            type : sampler2d,
            name : albedoTexture
        },
        {
            type : sampler2d,
            name : normalTexture
        },
        {
            type : float4,
            name : baseColor
        },
        {
            type : sampler2d,
            name : metalMap
        },
        {
            type : float,
            name : textureScaler
        },
        {
            type : float,
            name : normalTextureScaler
        },
        {
            type : float,
            name : reflectance
        },
        {
            type : float,
            name : metallic
        },
        {
            type : float,
            name : clearCoat
        },
        {
            type : float,
            name : bumpScale
        },
        {
            type : int,
            name : useNormalMap
        },
        {
            type : int,
            name : useMetallicTexture
        },
        {
            type : int,
            name : useBumpTexture
        },
        {
            type : int,
            name : useAlbedoTexture
        },
        {
            type : int,
            name : useRoughnessTexture
        },
        { // this is a compatibility attribute with the GltfViewer extra tweaks
            type : float4,
            name : scalingControl
        },
        { // this is a compatibility attribute with the Filament generated materials
            type : float,
            name : normalScale
        },
        { // this is a compatibility attribute with the Filament generated materials
            type : float,
            name : clearCoatNormalScale
        }
    ]
}

fragment {
    const float EPSILON = 1.0 / 2048.0;

    vec4 triplanarTexture(sampler2D tex, highp vec3 pos, lowp vec3 normal) {
        // Depending on the resolution of the texture, we may want to multiply the texture coordinates
        vec3 queryPos = materialParams.textureScaler * pos;
        // We assume that the normal is of unit length, so below is an actual barycentric combination
        return (normal.x * normal.x) * texture(tex, queryPos.yz) +
               (normal.y * normal.y) * texture(tex, queryPos.xz) +
               (normal.z * normal.z) * texture(tex, queryPos.xy);
    }

    // A simple linear blend with normalization
    vec3 computeWeights( vec3 normal ) {
#if 0
        // This was the blend Zaza used:
        return normal * normal;
#else
        // This one has a region where there is no blend, creating more defined interpolations
        vec3 blend = abs(normal.xyz);
        blend = max(blend - 0.2, vec3(0.0) );
        blend /= (blend.x + blend.y + blend.z);
        return blend;
#endif
    }

    vec3 unpackNormal( vec2 packedNormal ) {
        float x = packedNormal.x * 2.0 - 1.0;
        float y = packedNormal.y * 2.0 - 1.0;
        return vec3( x, y, sqrt( clamp( 1.0 - x*x - y*y, 0.0, 1.0 ) ) );
    }
    vec3 unpackNormal( vec3 packedNormal ) {
        return packedNormal * 2.0 - 1.0;
    }
    // This is a whiteout blended tripalanar normal mapping, where each plane's tangent frame is
    // approximated by the appropriate sequence and flips of world space axes. For more details
    // Refer to https://bgolus.medium.com/normal-mapping-for-a-triplanar-shader-10bf39dca05a
    vec3 triplanarNormalMap( sampler2D normalMap, highp vec3 pos, lowp vec3 normal ) {
        // Whiteout blend
        // Triplanar uvs
        vec2 uvX = materialParams.textureScaler * pos.zy; // x facing plane
        vec2 uvY = materialParams.textureScaler * pos.xz; // y facing plane
        vec2 uvZ = materialParams.textureScaler * pos.xy; // z facing plane
        // Tangent space normal maps
#if 0
        // 3-channel TS normal texture
        lowp vec3 tnormalX = unpackNormal( texture( normalMap, uvX ).xyz );
        lowp vec3 tnormalY = unpackNormal( texture( normalMap, uvY ).xyz );
        lowp vec3 tnormalZ = unpackNormal( texture( normalMap, uvZ ).xyz );
#else
        // 2-channel XY TS normal texture: this saves 33% on storage, but also
        // pushes us into the direction of choosing what attributes to pack
        // together into the same texture (e.g. normal-roughness-metallic?)
        lowp vec3 tnormalX = unpackNormal( texture( normalMap, uvX ).xy );
        lowp vec3 tnormalY = unpackNormal( texture( normalMap, uvY ).xy );
        lowp vec3 tnormalZ = unpackNormal( texture( normalMap, uvZ ).xy );
#endif
        // Swizzle world normals into tangent space and apply Whiteout blend
        tnormalX = vec3(
            tnormalX.xy + normal.zy,
            abs(tnormalX.z) * normal.x
            );
        tnormalY = vec3(
            tnormalY.xy + normal.xz,
            abs(tnormalY.z) * normal.y
            );
        tnormalZ = vec3(
            tnormalZ.xy + normal.xy,
            abs(tnormalZ.z) * normal.z
            );
        // Compute blend weights
        vec3 blend = computeWeights( normal );
        // Swizzle tangent normals to match world orientation and triblend
        return normalize( tnormalX.zyx * blend.x +
                          tnormalY.xzy * blend.y +
                          tnormalZ.xyz * blend.z );
    }

    void material(inout MaterialInputs material) {
        material.specularScale  = 1.0 + materialParams.scalingControl.x;
        material.roughnessScale = 1.0 + materialParams.scalingControl.y;
        material.diffuseScale   = 1.0 + materialParams.scalingControl.z;
        material.clearCoatScale = 1.0 + materialParams.scalingControl.w;

        highp vec3 pos = getWorldPosition() + getWorldOffset();
        highp vec3 normal = getWorldGeometricNormalVector();

        if ( materialParams.useNormalMap == 1 ) {
            normal = triplanarNormalMap( materialParams_normalTexture, pos, normal );
            material.normal = normal;
        }

        mat3 tangentFrame = getWorldTangentFrame();
        if ( materialParams.useBumpTexture == 1 ) {
            float bump = materialParams.bumpScale * triplanarTexture(materialParams_bumpTexture, pos, normal).r;
            highp float dBumpDu = (materialParams.bumpScale * triplanarTexture(materialParams_bumpTexture, pos + EPSILON * tangentFrame[0], normal).r - bump);
            highp float dBumpDv = (materialParams.bumpScale * triplanarTexture(materialParams_bumpTexture, pos + EPSILON * tangentFrame[1], normal).r - bump);

            highp vec3 du = tangentFrame[0] + dBumpDu * normal;
            highp vec3 dv = tangentFrame[1] + dBumpDv * normal;

            if ( materialParams.useNormalMap == 1 ) {
                material.normal = normalize( material.normal + normalize(cross(du, dv) * tangentFrame) );
            } else {
                vec3 bumpNormal = normalize(cross(du, dv) * tangentFrame);
                material.normal = normalize( vec3( material.normal.xy * bumpNormal.z + bumpNormal.xy * material.normal.z , 1.0) );
            }
        }
        // By this time the normal should be ready, it is safe to apply the normal scale
        material.normal.xy *= materialParams.normalScale;

        // Let Filament compute the global shading parameters. Note that material.normal stays in tangent space. Its world space coordinates
        // are stored in the global variable shading_normal.
        prepareMaterial(material);

        // And overwrite whatever we need to overwrite
        if ( materialParams.useAlbedoTexture == 1 ) {
            material.baseColor = triplanarTexture(materialParams_albedoTexture, pos, normal);
        } else {
            material.baseColor = materialParams.baseColor;
        }

        // TODO @gvalasek: to conform to standards, .r is treated as occlusion, .b is roughness,
        //       and .b as metallness. For now, only roughness is taken into account for M2.
        if ( materialParams.useRoughnessTexture == 1 ) {
            material.roughness = triplanarTexture(materialParams_roughnessTexture, pos, normal).r;
        } else {
            material.roughness = materialParams.roughness;
        }

        // TODO @gvalasek: see as above, technically all this should have been a single fetch
        if ( materialParams.useMetallicTexture == 1 ) {
            material.metallic = triplanarTexture(materialParams_metalMap, pos, normal).r;
        } else {
            material.metallic = materialParams.metallic;
        }

        // Careful: reflectance affects non-metals, so this can make things overly shiny
        material.reflectance = materialParams.reflectance;

        material.anisotropy = 0.0;
        material.clearCoat = materialParams.clearCoat;
    }
}